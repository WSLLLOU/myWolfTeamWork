%YAML:1.0
---

Time: "Fri Sep 16 21:16:31 2022"

## TODO: 下面三个参数是有关联的, 可以尝试整合
# 当前哨岗身份 主/副
# 0  "主哨岗"
# 1  "副哨岗"
watchtower_identity: 0

# 当前身份 蓝/红
# 0  "blue"   现在为蓝方
# 1  "red"    现在为红方
team_color_: 1

# 数据矫正函数模式
# 0  蓝方[主哨岗] D1
# 1  蓝方[副哨岗] D3
# 2  红方[主哨岗] D4
# 3  红方[副哨岗] D2
fix_position_method_: 2


# 标4点位置切换
# 0 点四边玻璃罩子
# 1 点中间各障碍物左下点
click_point_method_: 0

# 哨岗相机离地高度 (mm)
watchtower_high_ : 1730.0
# 车半身高度 (mm)
half_car_high_: 250.0

## 下两个参数, 表示相机镜头距离角落的偏移量, 镜头偏向场地内部时间, 数为正数
# 相机偏移量 X (cm)
offset_x_ : 9
# 相机偏移量 Y (cm)
offset_y_ : 12

# 双哨岗数据融合--距离阈值
# 主副哨岗数据融合, 得出相同身份的两点, 相距大于该数值(60cm), 则认为不是同一台车
# cm
merge_same_car_distance_: 60

# [多帧]确定同色同号情况投票阈值
# 连续联系 [多少帧] 才可判断为同色同号情况
judge_same_color_num_mode_frames_thershold_: 35

# 同色同号判断严格程度
# 0 "strict"     [严格]需要场上四台车都在, 但条件还是很严格(主哨岗连续检测+条件严格), 主哨岗检测不完全就不行;
# 1 "relaxed"    [宽松]不限场上多少台车, 主哨岗能 `连续检测` 到一对同色同号即可, 但主哨岗检测不到还是不行;
judge_same_color_num_mode_conditions_: 1

# [多帧]确定卧底号数识别投票阈值
# 最少连续判断 [多少帧] 才可判断出卧底号数
judge_discoloration_car_num_frames_thershold_: 35

# [单帧]卧底号数识别
# 当Car1, Car2给哨岗发数据的时候, 可利用哨岗检测到的同样号数的坐标数据
# 求两个坐标数据之间的距离, 若距离小于当前设定的距离阈值, 则判断哨岗检测到的该敌方颜色车辆为己方
# 判断该车是否为己方的距离阈值
judge_discoloration_car_num_distance_: 65

# [同色同号后--只发送敌方车辆坐标]
# 同色同号后, 根据哨岗检测到的车辆坐标数据(同一个类别) 和 Car自身发给我的坐标数据 进行对比, 判断出那个坐标为敌方坐标
# 判断离Car坐标数据最远的那个坐标数据是否超过设定的该距离阈值(70cm), 若超过, 则可以判断该数据为敌方坐标
# cm
judge_emeny_car_distance_: 70


# 发送 消息 IP (即本机在该网络上的IP)
# std::string tower_self_ip = tcp://*:5556
tower_self_ip_: "tcp://*:5556"

# 接收 副哨岗 IP
# std::string other_tower_ip = "tcp://192.168.1.154:5556"
other_tower_ip_: "tcp://192.168.1.154:5556"

# 接收 car_1 IP
# std::string car_1_ip = "tcp://192.168.1.66:5555"
car_1_ip_: "tcp://192.168.1.66:5555"

# 接收 car2 IP
# std::string car_2_ip = "tcp://192.168.1.88:5555"
car_2_ip_: "tcp://192.168.1.88:5555"